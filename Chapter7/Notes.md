# 第七章 类 （Class）

## 定义抽象数据类型

- **类背后的基本思想**：**数据抽象**（data abstraction）和**封装**（encapsulation）。
- 数据抽象是一种依赖于**接口**（interface）和**实现**（implementation）分离的编程技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

- 封装实现了类的接口与实现的分离。封装后的类隐藏了其细节，类的用户只能使用接口而无法访问实现部分。

- 类要想实现数据抽象和封装，首先需要定义一个**抽象数据类型（abstract data type）**

```cpp
struct Sales_data {
    std::string isbn() const { return bookNo; };
    Sales_data& combine(const Sales_data&);
    
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

Sales_data& Sales_data::combine(const Sales_data& rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
```

### 类成员 （Member）

- 必须在类的内部声明，不能在其他地方增加成员。
- 成员可以是数据，函数，类型别名。

#### 定义成员函数
- 尽管所有的成员都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。
- 成员函数的**声明**必须在类的内部。
- 成员函数的**定义**既可以在类的内部也可以在外部。
- 使用点运算符 `.` 调用成员函数。
- 必须对任何`const`或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。
- `ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { }`
- 默认实参： `Sales_item(const std::string &book): isbn(book), units_sold(0), revenue(0.0) { }`

#### 引入this
- 当我们在调用成员函数时，实际上是在替某个对象调用它。
- 成员函数通过一个名为**this**的而外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，永清球杆函数的对象地址初始化`this`, For example:

```cpp
total.isbn()
```
编译器负责把total的地址传递给`isbn`的隐式形参`this`，因策可以等价认为编译器将该调用重写为
```cpp
// 伪代码 pseudo code
Salse_data::isbn(&total)
```

- 每个成员函数都有一个额外的，隐含的形参`this`。
- `this`总是指向当前对象，因此`this`是一个常量指针。
- 形参表后面的`const`，改变了隐含的`this`形参的类型，如 `bool same_isbn(const Sales_item &rhs) const`，这种函数称为“常量成员函数”（`this`指向的当前对象是常量）。
- `return *this;`可以让成员函数连续调用。

#### 引入const成员函数

- 普通的非`const`成员函数：`this`是指向类类型的`const`指针（可以改变`this`所指向的值，不能改变`this`保存的地址）。例如在`Sales_data`成员函数中，`this`的类型是`Sales_data *const`。

- `const`成员函数：`this`是指向const类类型的`const`指针（既不能改变`this`所指向的值，也不能改变`this`保存的地址）。
#### 非成员函数

- 和类相关的非成员函数，定义和声明都应该在类的外部。


### 7.1.4 构造函数

- 类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。
- 构造函数没有返回类型。
- 构造函数不能被声明为`const`的。
- 构造函数是特殊的成员函数。
- 构造函数放在类的`public`部分。
- 与类同名的成员函数。
- `Sales_item(): units_sold(0), revenue(0.0) { }`
- `=default`要求编译器合成默认的构造函数。(`C++11`)
    `Sales_item() = default;`
- 初始化列表：冒号和花括号之间的代码： `Sales_item(): units_sold(0), revenue(0.0) { }`
#### 合成的默认构造函数

编译器创建的构造函数又被成为**合成的默认构造函数（synthesized default constructor）**。 

#### 某些类不能依赖于合成的默认构造函数

- 合成的默认构造函数只适合非常简单的类。
- 普通的类必须定义它自己的**默认构造函数** why?
    * 编译器只有在发现类不包含任何构造函数的情况下才会生成默认构造函数
    * 对于某些类来说，合成的默认构造函数可能执行错误的操作
    * 有时编译器不能为某些类合成默认的构造函数。

#### 构造函数初始值列表
`Sales_item(): units_sold(0), revenue(0.0) { }`
- 花括号定义了（空的）函数体
- 冒号及冒号和花括号之间的代码称为**构造函数初始值列表（constructor initialize list）**，负责为新创建的对象的一个或几个数据成员赋初值。

#### 类的外部定义构造函数
- 

### 7.1.5 拷贝、赋值与析构

- 对象在几种情况下会被拷贝。
    * 初始化变量以及以值的方式传递货返回一个对象等
    * 使用了赋值运算符时会发生对象的赋值操作
    * 当对象不再存在是执行销毁的操作
> 如果不主动定义，编译器会替代合成它们。编译器生成的版本将对对象的每个成员进行操作。

#### 某些类不能依赖于合成的版本
- 当类需要分配对象之外的资源时，合成的版本常常会失效

> 很多需要动态内存的类能（而且应该）使用vector对象或者string对象管理存储空间。能有效避免分配和释放内存带来的复杂性。
## 7.2 访问控制和封装
- **访问说明符**（access specifiers）： 加强类的封装性
    * `public`：定义在 `public`后面的成员在整个程序内可以被访问； `public`成员定义类的接口。
    * `private`：定义在 `private`后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； `private`隐藏了类的实现细节。

- `class` 与 `struct` 关键字的区别
    * 都可以被用于定义一个类。唯一的却别在于访问权限。
    - 使用 `class`：在第一个访问说明符之前的成员是 `priavte`的。
    - 使用 `struct`：在第一个访问说明符之前的成员是 `public`的。

### 7.2.1 友元(friend)

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为他的**友元（friend）**
- 友元声明只能出现在类定义的内部，但是类内出现的具体位置不限。
- 友元的声明以关键字 `friend`开始。 `friend Sales_data add(const Sales_data&, const Sales_data&);`表示非成员函数`add`可以访问类的非公有成员。
> 一般来说最好类定义开始或结束前的位置集中声明友元

#### 友元的声明

- 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。 如果希望类的用户能够调用某个友元函数，必须在友元声明之外再专门对函数进行一次声明。

#### 封装的益处

- 确保用户的代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

## 7.3 类的其他特性

### 7.3.1
- 成员函数作为内联函数 `inline`：
  - 在类的内部，常有一些规模较小的函数适合于被声明成内联函数。
  - **定义**在类内部的函数是**自动内联**的。
  - 在类外部定义的成员函数，也可以在声明时显式地加上 `inline`。

- 重载成员函数
    - 只要函数之间在参数的数量和(或)类型上有所区别就行。

- **可变数据成员** （mutable data member）：
  - 有时希望修改类内的某个数据成员，可以通过在变量的声明中加入`mutable`关键字
  - `mutable size_t access_ctr;`  一个const成员函数可以改变一个可变成员的值。
  - 永远不会是`const`，即使它是`const`对象的成员。  

- 类数据成员的初始值
    - 当我们提供一个类内初始值时，必须以符号`=`或者花括号表示。

### 7.3.2

- 从`const`成员函数返回`*this`
    - >一个const成员函数如果以引用的形式返回*this，那么他的返回类型将是常量引用。

- 基于const的重载 
    -通过区分成员函数是否是const的，可以对其进行重载



### 7.3.3 类类型

- 每个类定义了唯一的类型，对于两个类来说，即使他们的成员完全一样，这两个类也完全不同。
    > 对于一个类来说，它的成员和其他类（或者任何其他作用域）的成员完全不同。

- 类的声明
    * 如同函数的定义与声明可以分离一样，也可仅仅声明类而暂时不定义，这种声明有时被称为**前向声明（forward declaration）**，
    * 对于一个类，创建它的对象之前该类必须被定义过，而不能仅仅被声明
    * 7.6节 描述了一种特殊的情况

### 7.3.4 友元再探


类除了能将普通的非成员函数定义为友元（refer to 7.2.1, p 241）, 类还可以将其他类定义为友元，也可以将其他类（以被定义过的）的成员函数声明为友元。
>友元函数能定义在类的内部，这样的函数是隐式内联的 

- 类之间的友元关系
    * 每个类负责控制自己的友元类或者友元函数，友元不具有传递性

- 成员函数作为友元
    * 当把一个成员函数作为友元时，必须明确指出该成员函数属于哪一类
    * 对重载函数分别声明

- 友元声明和作用域
    * 即使在类的内部定义该函数，也必须在类的外部提供相应的声明从而使得函数可见，即该函数必须是声明过的。

## 7.4 类的作用域

- 作用域和定义在类外部的成员
    
    
    一个类就是一个作用域，所以在类的外部定义成员函数时必须同时提供类名和函数名。 在类的外部，成员的名字被隐藏起来了。
    * 一旦遇到类名，定义的剩余部分就在类的作用域之内了， 可以直接使用类的其他成员而无需再次授权。
    * 函数的返回类型必须指明它是哪个类的成员

### 7.4.1 名字查找与类的作用域

**名字查找（name lookup）**（寻找与所用名字最匹配的声明的过程）
    - 在类中首先编译成员的声明
    - 直到全部类可见后才编译函数体

#### 用于类成员声明的名字查找

上述两阶段的处理方式只适用于成员函数中使用的名字。而声明中使用的名字，包括返回类型或者参数列表中使用的名字及类型，必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，编译器会在定义该类的作用域中继续查找。

#### 类型名要特殊处理


如果在类中，有成员使用了外层作用域中的某个名字，而且改名字代表一种类型，则类不能在之后重新定义该名字。

>Tips: 类型名的定义通常出现在类的开始，确保所有使用该类型的成员都出现在其之后

#### 成员定义中的普通作用域的名字查找

- 首先在成员函数中查找。 只有使用之前出现的声明才被考虑。
- 如果成员函数内没有找到，类内继续查找。
- 如果类内也没找到，则在成员函数定义之前的作用域内继续查找。

#### 类作用域之后，在外围的作用域中继续查找

>尽管外层的对象被隐藏，我们仍然可以用作用域运算符`::`访问它。

## 7.5 构造函数再探

### 7.5.1 构造函数初始值列表

建议使用构造函数初始值。

#### 成员初始化的顺序

成员的初始化顺序与它们在类出现的顺序一致。若是一个成员`i`使用另外一个成员`j`来初始化，必须保证成员`j`初始化在成员`i`之前。

最好使用构造函数的参数作为成员的初始值。这样成员初始化的顺序就没什么影响了。

#### 默认实参和构造函数
>如果一个构造函数为所有参数都提供了默认实参，则它实际也定义了默认构造函数

### 7.5.2 委托构造函数
C++11 扩展了构造函数初始值的功能，使得我们可以定义所谓的**委托构造函数（delegating constructor）**.

一个委托构造函数使用它所属类的构造函数执行它自己的初始化过程。

- 受委托的构造函数体如果包含代码，将先执行这些代码，然后控制权才会交还给委托者的函数体

### 7.5.3 默认构造函数的作用

在实际中，如果定义了其它构造函数，那么最好提供一个默认构造函数。

### 7.5.4 隐式的类型转换

同样可以为类定义隐式转换规则，如果构造函数只接受了*一个实参*，实际上它定义了转换为此类型的隐式转换机制，将这种构造函数称为**转换构造函数（converting constructor）**. 14.9节会介绍如何定义规则。

>能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型的隐式转换的规则。

- 编译器只会自动地执行一步类型转换。
- 类类型转换不是总有效的
- 通过将构造函数声明为**explicit**加以抑制构造函数定义的隐式转换。
    - 只对一个实参的构造函数有效，需要多个实参的构造函数不能用于隐式转换，无须将其指定为`explicit`。 
    - 只能在类内声明构造函数时使用关键字，在类外部定义时不应重复。
    - 只能用于直接初始化。发生隐式转换时的一种情况是执行拷贝形式的初始化（=）， explicit构造函数不能用于拷贝形式的初始化过程。

- 为转换显式地使用构造函数。
    - ``static_cast`可以使用explicit的构造函数
- 标准库中含有显式构造函数的类
    - 接受一个单参数的const char* 的string 构造函数**不是**explicit的。
    - 接受一个容量参数的vector构造函数时explicit的。


### 7.5.5 聚合类

- **聚合类**（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。须满足以下条件：
    
    - 所有的成员都是public的
    - 没有定义任何构造函数
    - 没有类内初始值。
    - 没有基类，也没有virtual函数
    例如
    ```cpp
    struct Data
    {
        int ival;
        string s;
    };
    ```
    > 可提供一个花括号括起来的成员初始值列表，利用它初始化聚合类的数据成员
        `Data val1 = {0, "Anna"};`

* 初始值的顺序必须与声明的顺序一致。

### 7.5.6 字面值常量类
- 数据成员都是字面值类型的聚合类是字面值常量类。 若一个类不是聚合类，但他符合下述要求，则它是一个字面值常量类。
    - 数据成员必须是字面值类型
    - 类必须至少含有一个`constexpr`构造函数
    - 如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的`constexpr`构造函数
    - 类必须使用析构函数的默认定义，该成员负责销毁类的对象
    - constexpr构造函数必须初始化所有数据成员
    - 综合来说，constexpr构造函数体一般来说是空的


## 7.6 类的静态成员

有时类需要它的一些成员与类本身直接相关，而不是与类的各个对象保持关联。更重要的是，一旦成员发生改变，希望所有的对象都能使用新值。

- **声明静态成员**
    - 通过在成员的声明前加上关键字`static`使得其与类关联在一起。
    - 类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。
    - 类似的，静态成员函数也不与任何对象绑定在一起，它们不包含this指针。 作为结果，静态成员函数**不能**声明为const的，也不能在static函数体内使用this指针。

- **使用类的静态成员**
    - 可以使用域作用符`::`直接访问静态成员
      
    
        ```cpp
        double r;
        r = Account::rate();  // 
        ```
    
    -  虽然静态成员不属于类的某个对象，仍可以使用类的对象、引用、指针来访问静态成员

        
        ```cpp
        Account ac1;
        Account *ac2 = &ac1;

        r = ac1.rate();         //通过Account对象或引用
        r = ac2->rate();        //通过指向Account的对象的指针
        ```

    - 成员函数不通过域作用符就能直接使用静态成员


- **定义静态成员**
    - 既可以在内部也可以在外部定义静态成员函数，在类的外部定义成员函数时，不能重复static关键字，该关键字只能出现在类的内部的声明语句。
        >和类的所有成员一样，指向类外部的静态成员时，必须指明成员所属的类名。
    
    - 因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义。 即不是由类的构造函数初始化的
        * **一般来说**，不能在类的内部初始化静态成员，相反，必须在类的外部定义和初始化每个静态成员，一个静态数据成员只能定义一次。
        * 类似于全局变量，静态数据成员定义在任何函数之外，因此一旦被定义，一直存在与程序的整个生命周期。
        * 定义静态数据成员的方式和在类的外部定义成员函数差不多。 需要制定对象的类型名，然后是类名，作用域运算符以及成员自己的名字：
            ```cpp
            double Account::interestRate = initRate();
            ```
    > 若想确保对象只定义了一次，最好的办法是将静态数据成员的定义与其它非内联函数的定义放在同一个文件中。

- **静态成员的类内初始化**
    - **一般来说**，不能在类的内部初始化静态成员。但是可以为静态成员提供 const证书类型的类内初始值，不过要求静态成员必须是字面值常量类型的constexpr。
    * 如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值。
    >及时一个常量静态数据成员在类内部被初始化，通常情况下也应该在类的外部定义一下该成员。

- 静态成员能用于某些场景，普通成员则不能
    - 静态数据成员可以使不完全类型（即类声明之后，定义之前）。静态数据成员的类型可以是它所属类的类型，而非静态数据成员只能声明为它所属类的指针或引用

        ```cpp
        class Bar
        {
        public:
        //---
        private:
            static Bar mem1;    //正确，静态成员可以是不完全类型
            Bar *mem2;          //正确，指针成员可以是不完全类型
            Bar mem3;           //error, 数据类型必须是完全类型
        }
        ```

    - 静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参。非静态成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果无法真正提供一个对象以便从中获取成员的值，最终引发错误。
