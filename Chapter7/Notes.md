# 第七章 类 （Class）

## 定义抽象数据类型

- **类背后的基本思想**：**数据抽象**（data abstraction）和**封装**（encapsulation）。
- 数据抽象是一种依赖于**接口**（interface）和**实现**（implementation）分离的编程技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

- 封装实现了类的接口与实现的分离。封装后的类隐藏了其细节，类的用户只能使用接口而无法访问实现部分。

- 类要想实现数据抽象和封装，首先需要定义一个**抽象数据类型（abstract data type）**

```cpp
struct Sales_data {
    std::string isbn() const { return bookNo; };
    Sales_data& combine(const Sales_data&);
    
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};

Sales_data& Sales_data::combine(const Sales_data& rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
```

### 类成员 （Member）

- 必须在类的内部声明，不能在其他地方增加成员。
- 成员可以是数据，函数，类型别名。

#### 定义成员函数
- 尽管所有的成员都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。
- 成员函数的**声明**必须在类的内部。
- 成员函数的**定义**既可以在类的内部也可以在外部。
- 使用点运算符 `.` 调用成员函数。
- 必须对任何`const`或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。
- `ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { }`
- 默认实参： `Sales_item(const std::string &book): isbn(book), units_sold(0), revenue(0.0) { }`

#### 引入this
- 当我们在调用成员函数时，实际上是在替某个对象调用它。
- 成员函数通过一个名为**this**的而外的隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，永清球杆函数的对象地址初始化`this`, For example:

```cpp
total.isbn()
```
编译器负责把total的地址传递给`isbn`的隐式形参`this`，因策可以等价认为编译器将该调用重写为
```cpp
// 伪代码 pseudo code
Salse_data::isbn(&total)
```

- 每个成员函数都有一个额外的，隐含的形参`this`。
- `this`总是指向当前对象，因此`this`是一个常量指针。
- 形参表后面的`const`，改变了隐含的`this`形参的类型，如 `bool same_isbn(const Sales_item &rhs) const`，这种函数称为“常量成员函数”（`this`指向的当前对象是常量）。
- `return *this;`可以让成员函数连续调用。

#### 引入const成员函数

- 普通的非`const`成员函数：`this`是指向类类型的`const`指针（可以改变`this`所指向的值，不能改变`this`保存的地址）。例如在`Sales_data`成员函数中，`this`的类型是`Sales_data *const`。

- `const`成员函数：`this`是指向const类类型的`const`指针（既不能改变`this`所指向的值，也不能改变`this`保存的地址）。
#### 非成员函数

- 和类相关的非成员函数，定义和声明都应该在类的外部。


### 7.1.4 构造函数

- 类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。
- 构造函数没有返回类型。
- 狗在函数不能被声明为`const`的。
- 构造函数是特殊的成员函数。
- 构造函数放在类的`public`部分。
- 与类同名的成员函数。
- `Sales_item(): units_sold(0), revenue(0.0) { }`
- `=default`要求编译器合成默认的构造函数。(`C++11`)
    `Sales_item() = default;`
- 初始化列表：冒号和花括号之间的代码： `Sales_item(): units_sold(0), revenue(0.0) { }`
#### 合成的默认构造函数

编译器创建的构造函数又被成为**合成的默认构造函数（synthesized default constructor）**。 

#### 某些类不能依赖于合成的默认构造函数

- 合成的默认构造函数只适合非常简单的类。
- 普通的类必须定义它自己的**默认构造函数** why?
    * 编译器只有在发现类不包含任何构造函数的情况下才会生成默认构造函数
    * 对于某些类来说，合成的默认构造函数可能执行错误的操作
    * 有时编译器不能为某些类合成默认的构造函数。

#### 构造函数初始值列表
`Sales_item(): units_sold(0), revenue(0.0) { }`
- 花括号定义了（空的）函数体
- 冒号及冒号和花括号之间的代码称为**构造函数初始值列表（constructor initialize list）**，负责为新创建的对象的一个或几个数据成员赋初值。

#### 类的外部定义构造函数
- 

### 7.1.5 拷贝、赋值与析构

- 对象在几种情况下会被拷贝。
    * 初始化变量以及以值的方式传递货返回一个对象等
    * 使用了赋值运算符时会发生对象的赋值操作
    * 当对象不再存在是执行销毁的操作
> 如果不主动定义，编译器会替代合成它们。编译器生成的版本将对对象的每个成员进行操作。

#### 某些类不能依赖于合成的版本
- 当类需要分配对象之外的资源时，合成的版本常常会失效

> 很多需要动态内存的类能（而且应该）使用vector对象或者string对象管理存储空间。能有效避免分配和释放内存带来的复杂性。
## 7.2 访问控制和封装
- **访问说明符**（access specifiers）： 加强类的封装性
    * `public`：定义在 `public`后面的成员在整个程序内可以被访问； `public`成员定义类的接口。
    * `private`：定义在 `private`后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； `private`隐藏了类的实现细节。

- `class` 与 `struct` 关键字的区别
    * 都可以被用于定义一个类。唯一的却别在于访问权限。
    - 使用 `class`：在第一个访问说明符之前的成员是 `priavte`的。
    - 使用 `struct`：在第一个访问说明符之前的成员是 `public`的。

### 7.2.1 友元(friend)

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为他的**友元（friend）**
- 友元声明只能出现在类定义的内部，但是类内出现的具体位置不限。
- 友元的声明以关键字 `friend`开始。 `friend Sales_data add(const Sales_data&, const Sales_data&);`表示非成员函数`add`可以访问类的非公有成员。
> 一般来说最好类定义开始或结束前的位置集中声明友元

#### 友元的声明

- 友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。 如果希望类的用户能够调用某个友元函数，必须在友元声明之外再专门对函数进行一次声明。

#### 封装的益处

- 确保用户的代码不会无意间破坏封装对象的状态。
- 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

## 7.3 类的其他特性

### 7.3.1
- 成员函数作为内联函数 `inline`：
  - 在类的内部，常有一些规模较小的函数适合于被声明成内联函数。
  - **定义**在类内部的函数是**自动内联**的。
  - 在类外部定义的成员函数，也可以在声明时显式地加上 `inline`。

- 重载成员函数
    - 只要函数之间在参数的数量和(或)类型上有所区别就行。

- **可变数据成员** （mutable data member）：
  - 有时希望修改类内的某个数据成员，可以通过在变量的声明中加入`mutable`关键字
  - `mutable size_t access_ctr;`  一个const成员函数可以改变一个可变成员的值。
  - 永远不会是`const`，即使它是`const`对象的成员。  

- 类数据成员的初始值
    - 当我们提供一个类内初始值时，必须以符号`=`或者花括号表示。

### 7.3.2

- 从`const`成员函数返回`*this`
    - >一个const成员函数如果以引用的形式返回*this，那么他的返回类型将是常量引用。

- 基于const的重载 
    -通过区分成员函数是否是const的，可以对其进行重载